<html><body><p>
<b>DEFVAR-UI (main-widget &rest variables)</b>
<p>This macro simplifies the definition of UI variables:</p>
<pre>
  (defvar-ui *main* *line-edit* ...) ; this will expand to:
  (progn (defvar *line-edit* (qfind-child *main* "line_edit")) ...)
</pre>
</p><br>
<p>
<b>QADD-EVENT-FILTER (object event function)</b>
<p>Adds a Lisp function to be called on a given event type.<br>If the object argument is <code>NIL</code>, the event will be captured for any object.<br>If the Lisp function returns <code>NIL</code>, the event will be processed by Qt afterwards.</p>
<pre>
  (qadd-event-filter nil |QEvent.MouseButtonPress| (lambda (obj ev) (print obj) nil))
</pre>
</p><br>
<p>
<b>QAPP ()</b>
<p>Convenience function returning <code>qApp</code>.</p>
</p><br>
<p>
<b>QAPROPOS (&optional search-string class-name)</b>
<p>Finds all occurrencies of the given search string in the given object's meta information.<br>Constructors are listed under "Methods".<br>To list the user defined functions of external C++ classes (see Qt_EQL), pass the object instead of the class name.</p>
<pre>
  (qapropos "html" "QTextEdit")
  (qapropos nil "QWidget")
  (qapropos)
  (qapropos nil *qt-main*) ; embedded C++ (see Qt_EQL)
</pre>
</p><br>
<p>
<b>QAPROPOS* (&optional search-string class-name)</b>
<p>Similar to <code>qapropos</code>, returning the results as nested list.</p>
</p><br>
<p>
<b>QCALL-DEFAULT ()</b>
<p>To use inside an overridden function (see <code>qoverride</code>).<br>Calls the base implementation of the virtual Qt method.</p>
</p><br>
<p>
<b>QCLEAR-EVENT-FILTERS ()</b>
<p>Clears all added event filters.</p>
</p><br>
<p>
<b>QCONNECT (caller signal receiver/function &optional slot)</b>
<p>Connects either a Qt signal to a Qt slot, or a Qt signal to a Lisp function.</p>
<pre>
  (qconnect edit "textChanged(QString)" label "setText(QString)")
  (qconnect edit "textChanged(QString)" (lambda (txt) (print txt)))
</pre>
</p><br>
<p>
<b>QCOPY (object)</b>
<p>Copies object if possible. Only few Qt classes allow copying.</p>
<pre>
  (qcopy pixmap)
</pre>
</p><br>
<p>
<b>QDELETE (object &optional later)</b>
<br>
<b>QDEL</b>
<p>Deletes any Qt object, and sets the <code>pointer</code> value to <code>0</code>. Deleting a widget deletes all its child widgets, too.<br>If <code>later</code> is not <code>NIL</code>, the function <code>QObject::deleteLater()</code> will be called instead.<br>See <code>qlet</code> for local Qt objects.<br>Returns <code>T</code> if the object has effectively been deleted.</p>
<pre>
  (qdel widget)
  (qdel socket :later)
</pre>
</p><br>
<p>
<b>QDISCONNECT (caller &optional signal receiver/function slot)</b>
<p>Disconnects signals to either Qt slots or Lisp functions. Everything but the caller can be either <code>NIL</code> or omitted.</p>
<pre>
  (qdisconnect edit "textChanged(QString)" label "setText(QString)")
  (qdisconnect edit "textChanged(QString)")
  (qdisconnect edit nil label)
  (qdisconnect edit)
</pre>
</p><br>
<p>
<b>QEQL (object1 object2)</b>
<p>Returns <code>T</code> for same instances of a Qt class.<br>To test for same Qt classes only, do:</p>
<pre>
  (= (qt-object-id object1) (qt-object-id object2))
</pre>
</p><br>
<p>
<b>QESCAPE (string)</b>
<p>Calls <code>Qt::escape()</code>.</p>
</p><br>
<p>
<b>QEXEC (&optional milliseconds)</b>
<p>Convenience function to call <code>QApplication::exec()</code>.<br>Optionally pass the time in milliseconds after which <code>QEventLoop::exit()</code> will be called.</p>
</p><br>
<p>
<b>QFIND-CHILD (object name)</b>
<p>Calls <code>qFindChild&lt;QObject*&gt;()</code>.<br>Can be used to get the child objects of any Qt object (typically from a UI, see <code>qload-ui</code>), identified by <code>objectName</code>.</p>
<pre>
  (qfind-child *main* "editor")
</pre>
</p><br>
<p>
<b>QFROM-UTF8 (byte-array)</b>
<p>Returns the byte array (vector of octets) converted using <code>QString::fromUtf8()</code>.</p>
</p><br>
<p>
<b>QGUI (&optional process-events)</b>
<p>Launches the <code>EQL</code> convenience GUI.<br>If you don't have an interactive environment, you can pass <code>T</code> to run a pseudo Qt event loop. A better option is to start the tool like so:<br><code>eql -qgui</code>, in order to run the Qt event loop natively.</p>
</p><br>
<p>
<b>QID (name)</b>
<p>Returns the internally used ID of the object name. Non QObject classes have negative ids.</p>
<pre>
  (qid "QWidget")
</pre>
</p><br>
<p>
<b>QINVOKE-METHOD (object function-name &rest arguments)</b>
<br>
<b>QFUN</b>
<p>Calls any of Qt methods, slots, signals ("emit" in jargon). Static methods can be called by passing the string name of an object.<br>For overloaded Qt methods you may need to pass the argument types (as for <code>qconnect</code> and <code>qoverride</code>). In these (very few) ambiguous cases you will see a runtime error message, together with a list of all possible candidates.</p>
<pre>
  (qfun item "setText" 0 "Some objects are EQL.")
  (qfun "QDateTime" "currentDateTime") ; static method
  (qfun slider "valueChanged" 10) ; emit signal
</pre>
</p><br>
<p>
<b>QINVOKE-METHOD* (object cast-class-name function-name &rest arguments)</b>
<br>
<b>QFUN*</b>
<p>Similar to <code>qinvoke-method</code>, additionally passing a class name, enforcing a cast to that class.</p>
<pre>
  (qfun* event "QKeyEvent" "key")
  (qfun* graphics-text-item "QGraphicsItem" "setPos" (list x y)) ; multiple inheritance problem
  (qfun* *qt-main* :qt "foo") ; embedded Qt/C++ (see Qt_EQL)
</pre>
</p><br>
<p>
<b>QLET (((var exp) ...) ...)</b>
<p>Similar to <code>let*</code>. Creates temporary Qt objects, deleting them at the end of the <code>qlet</code> body. If <code>exp</code> is a string, it will be substituted with <code>(qnew exp)</code>, optionally including constructor arguments.</p>
<pre>
  (qlet ((painter "QPainter")) ...)
  (qlet ((reg-exp "QRegExp(QString)" "^\\S+$")) ...)
</pre>
</p><br>
<p>
<b>QLOAD-UI (file-name)</b>
<p>Calls a custom <code>QUiLoader::load()</code> function, loading a UI file created by Qt Designer. Returns the top level widget of the UI.<br>Use <code>qfind-child</code> to retrieve the child widgets.</p>
<pre>
  (qload-ui "my-fancy-gui.ui")
</pre>
</p><br>
<p>
<b>QLOCAL8BIT (string)</b>
<p>Returns the string converted using <code>QString::toLocal8Bit()</code> (see <code>QLocale</code> settings).<br>Depending on the OS, this can be necessary if you get a filename from Qt and want to use it in Lisp.</p>
</p><br>
<p>
<b>QMESSAGE-BOX (x)</b>
<br>
<b>QMSG</b>
<p>Convenience function: a simple message box, converting x to a string if necessary.</p>
</p><br>
<p>
<b>QNEW-INSTANCE (class-name &rest arguments/properties)</b>
<br>
<b>QNEW</b>
<p>Creates a new Qt object, optionally passing the given arguments to the constructor. Additionally you can pass any number of property/value pairs.<br>Please note how you can abbreviate long type lists.</p>
<pre>
  (qnew "QWidget")
  (qnew "QPixmap(int,int)" 50 50) ; constructor
  (qnew "QLabel" "text" "I love me.") ; set property
  (qnew "QMatrix4x4(qreal...)" 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4)
</pre>
</p><br>
<p>
<b>QNULL-OBJECT (object)</b>
<p>Checks for a <code>0</code> Qt object pointer.</p>
</p><br>
<p>
<b>QOBJECT-NAMES (&optional type)</b>
<p>Returns all supported object names. Passing either <code>:q</code> or <code>:n</code> returns only the QObject inherited, or not QObject inherited names, respectively.</p>
</p><br>
<p>
<b>QOK ()</b>
<p>Needed to get the boolean <b>ok</b> value in cases like this:</p>
<pre>
  (qfun "QFontDialog" "getFont(bool*)" nil)
</pre>
</p><br>
<p>
<b>QOVERRIDE (object name function)</b>
<p>Sets a Lisp function to be called on a virtual Qt method.<br>To remove a function, pass <code>NIL</code> instead of the function argument.<br>Use <code>qcall-default</code> inside your function to call the base implementation.</p>
<pre>
  (qoverride edit "keyPressEvent(QKeyEvent*)" (lambda (ev) (print (qfun ev "key")) (qcall-default)))
</pre>
</p><br>
<p>
<b>QPROCESS-EVENTS ()</b>
<p>Convenience function to call <code>QApplication::processEvents()</code>.</p>
</p><br>
<p>
<b>QPROPERTY (object name)</b>
<br>
<b>QGET</b>
<p>Gets a Qt property. Enumerator values are returned as <code>int</code> values.</p>
<pre>
  (qget label "text")
</pre>
</p><br>
<p>
<b>QQUIT ()</b>
<br>
<b>QQ</b>
<p>Quits both Qt and ECL.</p>
</p><br>
<p>
<b>QREQUIRE (module)</b>
<p>Loads an EQL module, corresponding to a Qt module. Returns the module name if both loading and initializing have been successful.<br>Available modules: <code>:help :network :opengl :sql :svg :webkit</code></p>
<pre>
  (qrequire :network)
</pre>
</p><br>
<p>
<b>QSELECT ()</b>
<br>
<b>QSEL</b>
<p>Allows to select (by clicking) any (child) widget. The variable <code>qsel:*q*</code> is bound to the latest selected widget.</p>
</p><br>
<p>
<b>QSENDER ()</b>
<p>Corresponding to <code>QObject::sender()</code>. To use inside a Lisp function connected to a Qt signal.</p>
</p><br>
<p>
<b>QSET-NULL (object)</b>
<p>Sets the Qt object pointer to <code>0</code>. This function is called automatically after <code>qdel</code>.</p>
</p><br>
<p>
<b>QSET-PROPERTY (object name value)</b>
<br>
<b>QSET</b>
<p>Sets a Qt property. Enumerators have to be passed as <code>int</code> values.</p>
<pre>
  (qset label "alignment" |Qt.AlignCenter|)
</pre>
</p><br>
<p>
<b>QSINGLE-SHOT (milliseconds function)</b>
<p>Convenience function: a single shot timer for Lisp functions (using <code>QTimer::singleShot</code>). You can use only 1 at a time, so if you need real timers, use <code>QTimer</code> directly.</p>
<pre>
  (qsingle-shot 0 'on-qt-idle)
</pre>
</p><br>
<p>
<b>QSTATIC-META-OBJECT (class-name)</b>
<p>Returns the static QMetaObject of the given class name (for <code>QObject</code> inherited classes).</p>
<pre>
  (qstatic-meta-object "QWidget")
</pre>
</p><br>
<p>
<b>QSUPER-CLASS-NAME (name)</b>
<p>Returns the super class of an object name, or <code>NIL</code> if the class doesn't inherit another Qt class.<br>Returns <code>T</code> as second return value for successful calls.</p>
<pre>
  (qsuper-class-name "QGraphicsLineItem")
</pre>
</p><br>
<p>
<b>QT-OBJECT-NAME (object)</b>
<p>Returns the Qt class name.</p>
</p><br>
<p>
<b>QUI-CLASS (file-name &optional object-name)</b>
<p>Finds the class name for the given user-defined object name in the given UI file.<br>Omitting the object name will return the top level class name of the UI.</p>
<pre>
  (qui-class "examples/data/main-window.ui" "editor") ; returns "QTextEdit"
</pre>
</p><br>
<p>
<b>QUI-NAMES (file-name)</b>
<p>Finds all user-defined object names in the given UI file.</p>
<pre>
  (qui-names "examples/data/main-window.ui")
</pre>
</p><br>
<p>
<b>QUTF8 (string)</b>
<p>Returns the string converted using <code>QString::toUtf8()</code>.<br>Depending on the OS, this can be necessary if you get a filename from Qt and want to use it in Lisp.</p>
</p><br>
<p>
<b>QVERSION ()</b>
<p>Returns the EQL version number as "&lt;year&gt;.&lt;month&gt;.&lt;counter&gt;", analogous to the ECL version number.<br>The second return value is the Qt version as returned by <code>qVersion()</code>.</p>
</p><br>
<p>
<b>TR (source &optional context plural-number)</b>
<p>Macro expanding to <code>qtranslate</code>, which calls <code>QCoreApplication::translate()</code>. Both <code>source</code> and <code>context</code> can be Lisp forms evaluating to constant strings (at compile time).<br>The <code>context</code> argument defaults to the Lisp file name. For the <code>plural-number</code>, see Qt Assistant.</p>
</p><br>
</body></html>